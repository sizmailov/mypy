from typing import Any, Iterable, Iterator, Tuple

from typing import overload

def get_complex_map() -> MapStringComplex: ...
def get_vector_of_pairs() -> VectorPairStringDouble: ...

class MapStringComplex:
    def __init__(self) -> None: ...
    def items(self) -> Iterator: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, arg0: str) -> bool: ...
    def __delitem__(self, arg0: str) -> None: ...
    def __getitem__(self, arg0: str) -> complex: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __setitem__(self, arg0: str, arg1: complex) -> None: ...

class VectorPairStringDouble:
    __hash__: Any = ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg0: VectorPairStringDouble) -> None: ...
    @overload
    def __init__(self, arg0: Iterable) -> None: ...
    @overload
    def __init__(*args, **kwargs) -> Any: ...
    def append(self, x: Tuple[str,float]) -> None: ...
    def clear(self) -> None: ...
    def count(self, x: Tuple[str,float]) -> int: ...
    @overload
    def extend(self, L: VectorPairStringDouble) -> None: ...
    @overload
    def extend(self, L: Iterable) -> None: ...
    @overload
    def extend(*args, **kwargs) -> Any: ...
    def insert(self, i: int, x: Tuple[str,float]) -> None: ...
    @overload
    def pop(self) -> Tuple[str,float]: ...
    @overload
    def pop(self, i: int) -> Tuple[str,float]: ...
    @overload
    def pop(*args, **kwargs) -> Any: ...
    def remove(self, x: Tuple[str,float]) -> None: ...
    def __bool__(self) -> bool: ...
    def __contains__(self, x: Tuple[str,float]) -> bool: ...
    @overload
    def __delitem__(self, arg0: int) -> None: ...
    @overload
    def __delitem__(self, arg0: slice) -> None: ...
    @overload
    def __delitem__(*args, **kwargs) -> Any: ...
    def __eq__(self, arg0: VectorPairStringDouble) -> bool: ...
    @overload
    def __getitem__(self, s: slice) -> VectorPairStringDouble: ...
    @overload
    def __getitem__(self, arg0: int) -> Tuple[str,float]: ...
    @overload
    def __getitem__(*args, **kwargs) -> Any: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __ne__(self, arg0: VectorPairStringDouble) -> bool: ...
    @overload
    def __setitem__(self, arg0: int, arg1: Tuple[str,float]) -> None: ...
    @overload
    def __setitem__(self, arg0: slice, arg1: VectorPairStringDouble) -> None: ...
    @overload
    def __setitem__(*args, **kwargs) -> Any: ...
